package compilatore;

import java_cup.runtime.*;
import java.io.*;
import java.lang.*;
import java.util.*;
import compilatore.*;

action code{:

String TRAD = "";
static String RegFP;
boolean flagP1 = true;
boolean flagP2 = true;
static boolean flagWarn = false;
int livP = 0;
static String Err_War = "";
static boolean checkFlag = false;
static boolean FlagExit = false;

int countReg = 0;
static int countRegFP = 0;
static int countRTemp = 0;
int countCl = 1;

ArrayList <String> vTrad = new ArrayList();
HashMap <String,String> TabTrad = new HashMap();

public void structProg(int levP, boolean flag, String trad) throws IOException{

   if(levP == 1){

      if(flag == true){
        Support.writeFile(true,"\n.data\n\n");
        System.out.println("\n.data\n");
      }
        Support.writeFile(true,trad+"\n");
       System.out.println(trad);
        flagP1 = false;
   }else if(levP == 2){

      if(flag == true){
          Support.writeFile(true,"\n.code\n\n");
         System.out.println("\n.code\n");
      
        ListIterator lsT = vTrad.listIterator();
        while(lsT.hasNext()){
            Support.writeFile(true,lsT.next().toString()+"\n");
            System.out.println(lsT.next());
        }   
      }
    Support.writeFile(true,trad);
    System.out.println(trad);
    flagP2 = false;
   }else{
    Support.writeFile(false,"\n\nend\n");   
    System.out.println("\nend\n");
   }   
}

:};



parser code{: 
             StringBuilder buffer;
             PrintText output;
             int currentPos;
             int currentLine;
             int col;
             char[] buf;


             public int returnLine()
             {
                return ((ExprLex)this.getScanner()).getLine();
             }
              
             public void report_error(String message, Object info)
             {
                buffer = new StringBuilder(message);
                buffer.append("Output Error: \n");
                output = new PrintText();
                   
                if(info==null)
                {
                   currentPos = ((ExprLex)this.getScanner()).getCurrentPos();
                   currentLine = ((ExprLex)this.getScanner()).getLine();
                   col = ((ExprLex)this.getScanner()).getColumn();
                   buf = ((ExprLex)this.getScanner()).getBuffer();
                   output = ((ExprLex)this.getScanner()).text();
                   buffer.append(output.getString());
                   buffer.append("\n");
                    
                   if(!output.getFlagBrack())
                   {
                     output.findLine(currentPos, currentLine,col,buf);
                     System.out.println(buffer.toString());
                     System.out.println("Riga n: "+output.getPos()+"\n");
                   }
                }else{
                   if(info instanceof Obj)
                   {
                    output = ((ExprLex)this.getScanner()).text();
                    buffer.append(output.getString());
                    System.out.println(buffer.toString());
                    System.out.println("riga num: "+returnLine()); 
                   }
                }
                    
             }
              
            public void syntax_error()
            {
               report_error("Errore  lessicale/sintattico \n",null);
            }
            
            public void warning(String message,Obj check) throws IOException
            {
                  buffer = new StringBuilder(message);
                  buffer.append("Output Warning: \n");
                  output = new PrintText();
                  output = ((ExprLex)this.getScanner()).text();
                  buffer.append(output.getString());
                  System.out.println(buffer.toString());
                  System.out.println("Riga n: "+returnLine());
            }

:}



                /* SIMBOLI TERMINALI (token restituiti dallo scanner) */
terminal BOOLEAN; 
terminal INT; 
terminal DOUBLE; 
terminal LBRACK, RBRACK; 
terminal PUNTO; 
terminal PUNTO_E_VIRGOLA, PER,VIRGOLA, LBRACE, RBRACE, EQ, TONDA_APERTA, TONDA_CHIUSA;
terminal PACKAGE; 
terminal IMPORT; 
terminal PUBLIC, PRIVATE; 
terminal STATIC; 
terminal FINAL;
terminal CLASS; 
terminal VOID; 
terminal IF, ELSE; 
terminal DO, WHILE; 
terminal FOR; 
terminal NEW; 
terminal PLUSPLUS; 
terminal MINUSMINUS; 
terminal PIU, MENO, DIVISO;
terminal LT, GT, LTEQ, GTEQ; 
terminal EQEQ, NOTEQ; 
terminal ANDAND; 
terminal OROR; 

terminal java.lang.Number INTEGER_LITERAL;
terminal java.lang.Number FLOATING_POINT_LITERAL;
terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal java.lang.Character CHARACTER_LITERAL;
terminal java.lang.String STRING_LITERAL;
terminal java.lang.String IDENTIFICATORE; // name
terminal NULL_LITERAL;


                                 /* NON TERMINALI */
non terminal Obj goal;
non terminal Obj literal;
non terminal Obj type, primitive_type, numeric_type;
non terminal Obj integral_type, floating_point_type;
non terminal Obj name, simple_name;
non terminal Obj compilation_unit;
non terminal Obj package_declaration_opt, package_declaration;
non terminal Obj import_declarations_opt, import_declarations;
non terminal Obj type_declarations_opt, type_declarations;
non terminal Obj import_declaration;
non terminal Obj single_type_import_declaration;
non terminal Obj type_import_on_demand_declaration;
non terminal Obj type_declaration;
non terminal Obj modifiers_opt, modifiers, modifier;
non terminal Obj class_declaration;
non terminal Obj class_body;
non terminal Obj class_body_declarations, class_body_declarations_opt;
non terminal Obj class_body_declaration, class_member_declaration;
non terminal Obj field_declaration, variable_declarators, variable_declarator;
non terminal Obj variable_declarator_id, variable_initializer;
non terminal Obj method_declaration, method_header, method_declarator;
non terminal Obj formal_parameter_list_opt;
non terminal Obj method_body;
non terminal Obj constructor_declaration;
non terminal Obj array_initializer;
non terminal Obj variable_initializers;
non terminal Obj block;
non terminal Obj block_statements_opt, block_statements, block_statement;
non terminal Obj local_variable_declaration_statement, local_variable_declaration;
non terminal Obj section_two;
non terminal Obj statement, statement_no_short_if;
non terminal Obj statement_without_trailing_substatement;
non terminal Obj empty_statement;
non terminal Obj expression_statement, statement_expression;
non terminal Obj if_then_statement;
non terminal Obj if_then_else_statement, if_then_else_statement_no_short_if;
non terminal Obj while_statement, while_statement_no_short_if;
non terminal Obj do_statement;
non terminal Obj for_statement, for_statement_no_short_if;
non terminal Obj for_init_opt, for_init;
non terminal Obj for_update_opt, for_update;
non terminal Obj statement_expression_list;
non terminal Obj primary, primary_no_new_array;
non terminal Obj array_creation_expression;
non terminal Obj dim_exprs, dim_expr, dims_opt, dims;
non terminal Obj array_access;
non terminal Obj postfix_expression;
non terminal Obj postincrement_expression, postdecrement_expression;
non terminal Obj unary_expression, unary_expression_not_plus_minus;
non terminal Obj cast_expression;
non terminal Obj multiplicative_expression, additive_expression;
non terminal Obj relational_expression, equality_expression;
non terminal Obj conditional_and_expression, conditional_or_expression;
non terminal Obj assignment_expression;
non terminal Obj assignment;
non terminal Obj left_hand_side;
non terminal Obj expression_opt, expression;


                               /* SIMBOLO DI PARTENZA */
start with goal;

                                   /* PRODUZIONI */
goal ::= compilation_unit
         ;

literal ::=	INTEGER_LITERAL:il {: RESULT = new Obj(Integer.toString((Integer)il),"INTEGER", "NUMERO"); :}
	|	FLOATING_POINT_LITERAL:fpl {: RESULT = new Obj(Double.toString((Double)fpl),"DOUBLE", "NUMERO"); :}
	|	BOOLEAN_LITERAL:boolit {: RESULT = new Obj(boolit?"true":"false", "BOOLEAN"); :}
	|	CHARACTER_LITERAL
	|	STRING_LITERAL:strlit {: RESULT = new Obj(strlit.replace("\"","\\\""),"STRING"); :}
	|	NULL_LITERAL {: RESULT = new Obj("null",""); :}
	;

type	::=	primitive_type:tipo_prim {: RESULT = tipo_prim; :}
	;
primitive_type ::=
		numeric_type:tipo_num {: RESULT = tipo_num; :}
	|	BOOLEAN:b {: RESULT = new Obj(b.toString(),"BOOLEAN"); :}
	;
numeric_type::=	integral_type:tipo_intero {: RESULT = tipo_intero; :}
	|	floating_point_type:tipo_dec {: RESULT = tipo_dec; :}
	;
integral_type ::= 
		INT:i {: RESULT = new Obj(i.toString(),"INTEGER"); :}
	;
floating_point_type ::= 
		DOUBLE:d  {: RESULT = new Obj(d.toString(),"DOUBLE"); :}
	;

                      /*SEZIONE PER LA GESTIONE DEI NOMI*/
name ::= simple_name:nome {: RESULT = nome; :}
	 ;
simple_name ::=	IDENTIFICATORE:ind {: RESULT = new Obj(ind.toString(),"IDENTIFICATORE"); :}
	        ;

/*GESTIONE DELLA PARTE INIZIALE CONTENENTE IL PACKAGE, GLI IMPORTI E LA CLASSE*/

compilation_unit ::= package_declaration_opt 
		     import_declarations_opt
		     type_declarations_opt
		     ;

package_declaration_opt ::= package_declaration | ;
import_declarations_opt ::= import_declarations | ;
type_declarations_opt   ::= type_declarations   | ;


import_declarations ::= import_declaration
	                |	
                        import_declarations import_declaration
	                ;
type_declarations ::= type_declaration
                      |
	              type_declarations type_declaration
	              ;
package_declaration ::= PACKAGE name PUNTO_E_VIRGOLA
	              ;

import_declaration ::= single_type_import_declaration
	               |	
                       type_import_on_demand_declaration
	               ;
single_type_import_declaration ::= IMPORT name PUNTO_E_VIRGOLA
	                           ;
type_import_on_demand_declaration ::= IMPORT name PUNTO PER PUNTO_E_VIRGOLA
	                              ;
type_declaration ::= class_declaration
	             |	
                     PUNTO_E_VIRGOLA
	             ;

                   /*SEZIONE PER LA GESTIONE DEI MODIFICATORI*/
modifiers_opt::=
          {: RESULT = new Obj(""); :} 
	|	modifiers:mod_opt {:  
                                   ProdParser.mods(mod_opt.testo);  
                                    
                                    if(checkFlag == true){                                       
                                       parser.report_error(Err_War, mod_opt);  
                                       checkFlag = false;
                                    }

                                    RESULT = mod_opt; 
                                   :}
	;
modifiers ::= 	modifier:mod {: RESULT = mod; :}
	|	modifiers:mods modifier:mod {: RESULT = new Obj(mods.testo+" "+mod.testo); :}
	;
modifier ::=	PUBLIC:pub {: RESULT = new Obj(pub.toString(),"PUBLIC"); :}
        |       PRIVATE:priv {: RESULT = new Obj(priv.toString(),"PRIVATE"); :}
	|	STATIC:stat {: RESULT = new Obj(stat.toString(),"STATIC"); :}
	|	FINAL:f {: RESULT = new Obj(f.toString(),"FINAL"); :} 
	;


class_declaration ::= 
	modifiers_opt CLASS simple_name class_body 
	;
class_body ::=	LBRACE {: UtilParser.newScope(); :} class_body_declarations_opt RBRACE {: 
                                                                                          UtilParser.delScope();
                                                                                          livP=3; 
                                                                                          structProg(livP,flagP2,"");
                                                                                        :}
	;
class_body_declarations_opt ::= 
	|	class_body_declarations ;
class_body_declarations ::= 
		class_body_declaration
	|	class_body_declarations class_body_declaration
	;
class_body_declaration ::=
		class_member_declaration
	|	constructor_declaration
	|	block
        ;
class_member_declaration ::=
		field_declaration
	|	method_declaration
	|       PUNTO_E_VIRGOLA
	;

                       /*SEZIONE RIGUARDANTE I CAMPI(VARIABILI) DI UNA CLASSE*/
field_declaration ::= 
		modifiers_opt type variable_declarators PUNTO_E_VIRGOLA                                                                                                                                                                                                    
        ;
variable_declarators ::=
		variable_declarator:vard {: RESULT = new Obj(vard.testo,vard.tipo); :}
	|	variable_declarators:vards VIRGOLA variable_declarator:vard {: RESULT = new Obj(vards.testo+", "+vard.testo); :}                                                 
        ;
variable_declarator ::=
		variable_declarator_id:vdi {: 
                                             if(vdi.tipo.equals("ARRAY")){
                                               vdi.testo = vdi.testo.replace("[]", "");
                                               Record rec = SymbolTable.getCurrRec(vdi.testo);
                                               rec.setValue("null");
                                             }else{
                                                Record rec = SymbolTable.getCurrRec(vdi.testo);
                                                rec.setValue("null"); 
                                             }

                                             RESULT = vdi; 
                                            :}
	|	variable_declarator_id:vdi EQ variable_initializer:vi {: 
                                                                        if(vdi.tipo.equals("ARRAY")){
                                                                          ProdParser.declArr(vdi.testo, vi.testo);
                                                                        }else{
                                                                          Record rec = SymbolTable.getCurrRec(vdi.testo);
                                                                          rec.setValue(vi.testo); 
                                                                        }
                                                                        
                                                                        RESULT = new Obj(vdi.testo+" = "+vi.testo, vi.tipo);                           
                                                                       :}
	;
variable_declarator_id ::=
		simple_name:nome {: 
                                   SymbolTable.addTb(nome.testo);
                                   
                                    if(checkFlag == true){                                                                                                                                                                        
                                        parser.report_error(Err_War,nome);
                                        checkFlag = false;  
                                        try{ wait(); }catch(Exception e){}                                        
                                    }
                                                
                                   RESULT = nome; 
                                  :}
	|	variable_declarator_id:vardid LBRACK RBRACK {: RESULT = new Obj(vardid.testo+"["+"]","ARRAY"); :}
	;
variable_initializer ::=
		expression:espr {: RESULT = espr; :}
	|	array_initializer:arrinit {: RESULT = arrinit; :}
	;

                           /*SEZIONE RIGUARDANTE I METODI DI UNA CLASSE*/
method_declaration ::=
		method_header:methead method_body:methbod 
	;
method_header ::=
		modifiers_opt:modopt VOID method_declarator:methdecl {: RESULT = new Obj(modopt.testo+" "+"void"+" "+methdecl.testo); :}
	;
method_declarator ::=
		simple_name:nome TONDA_APERTA formal_parameter_list_opt:fparlopt TONDA_CHIUSA {: RESULT = new Obj(nome.testo+"("+fparlopt.testo+")");                                                                                                                                                                                                  
                                                                                               :}
	;
formal_parameter_list_opt ::=
        {: RESULT = new Obj(""); :}
	;
method_body ::=	block:bl {: structProg(livP,flagP2,bl.testo); :}              
        |	PUNTO_E_VIRGOLA:pev {: RESULT = new Obj(pev.toString()); :}
	;
               
                      /*SEZIONE RIGUARDANTE L'INIZIALIZZAZIONE DI UN ARRAY*/
array_initializer ::=
		LBRACE variable_initializers:varinits VIRGOLA RBRACE {: RESULT = new Obj(varinits.testo+", "); :}
	|	LBRACE variable_initializers:varinits RBRACE {: RESULT = new Obj(varinits.testo,varinits.tipo); :}
	|	LBRACE VIRGOLA RBRACE {: RESULT = new Obj("{"+" , "+"}"); :}
	|	LBRACE RBRACE {: RESULT = new Obj("{"+"}"); :}
	;
variable_initializers ::=
		variable_initializer:varinit {: RESULT = varinit; :}
	|	variable_initializers:varinits VIRGOLA variable_initializer:varinit {:
                                                                                      if(varinits.tipo.equals(varinit.tipo)){
                                                                                         varinits.tipo=varinits.tipo;
                                                                                      }else{
                                                                                         varinits.tipo="DOUBLE";
                                                                                      }
                                                                                                                                                                            
                                                                                      RESULT = new Obj(varinits.testo+", "+varinit.testo,varinits.tipo); 
                                                                                     :}
	;

                              /*SEZIONE RIGUARDANTE I BLOCCHI*/
block ::= LBRACE {: UtilParser.newScope(); :} block_statements_opt:blstatmso RBRACE {: RESULT = blstatmso;
                                                                                       UtilParser.delScope(); 
                                                                                     :} 
	;
block_statements_opt ::=
	 {: RESULT = new Obj(""); :}
        |	block_statements:blstatms {: RESULT = blstatms; :}
	;
block_statements ::=
		block_statement:blstatm {: RESULT = blstatm; :}
	|	block_statements:blstatms block_statement:blstatm {: RESULT = new Obj(blstatms.testo+"\n"+blstatm.testo); :}
	;

                            //QUI AVVIENE LA STAMPA DELLA TRADUZIONE 
block_statement ::=
                local_variable_declaration_statement:lvds {: 
                                                            structProg(livP,flagP1,lvds.testo);
                                                            RESULT = new Obj("");
                                                          :}
	|	section_two:sectwo {: RESULT = sectwo; :}       
        |	class_declaration
	;

                        /*DICHIARAZIONE DELLE VARIABILI LOCALI*/
local_variable_declaration_statement ::=
		local_variable_declaration:lvd PUNTO_E_VIRGOLA {: 
                                                                 livP = 1;                                                                 
                                                                 RESULT = lvd; 
                                                                :}
	;
local_variable_declaration ::=
		type:tipo variable_declarators:vard  {: 
                                                        String Rg;
                                                        String TR;
                                                        if(vard.tipo.equals("IDENTIFICATORE")){
                                                          
                                                          vard.tipo=tipo.tipo;                                                                                                                    
                                                          Record rec = SymbolTable.getCurrRec(vard.testo);
                                                          rec.setType(vard.tipo);

                                                          if(vard.tipo.equals("DOUBLE")){
                                                            Rg = "$f"+countRegFP;
                                                            TR = "MOVE.D"+" "+vard.testo+","+" "+Rg;
                                                            countRegFP = countRegFP + 2;
                                                          }else{
                                                            Rg = "$s"+countReg;
                                                            TR = "MOVE"+" "+vard.testo+","+" "+Rg;
                                                            countReg++;
                                                          }
                                                          
                                                          rec.setRegister(Rg);                                
                                                          vTrad.add(TR);
                                                          
                                                        }else{
                                                         
                                                          vard.tipo = CheckClass.checkTypeA(tipo.tipo,vard.tipo,vard.testo);

                                                          if(checkFlag == true){                                                                                                                                                                    
                                                                parser.report_error(Err_War,vard);
                                                                checkFlag = false;
                                                                try{ wait(); }catch(Exception e){}
                                                          }
                                                          
                                                          flagWarn = false;
                                                          String VAR = Support.getVar(vard.testo);
                                                          Record rec = SymbolTable.getCurrRec(VAR);
                                                          rec.setType(vard.tipo);
                                                          
                                                          if(vard.testo.contains("[]")){
                                                             
                                                             Rg = "$s"+countReg;
                                                             rec.setRegDim(Rg);
                                                             TR = "MOVE"+" "+"dim"+","+" "+Rg;
                                                             vTrad.add(TR);
                                                             countReg++;
                                                             
                                                             if(vard.tipo.equals("DOUBLE")){
                                                               Rg = "$f"+countRegFP;
                                                               TR = "MOVE.D"+" "+VAR+","+" "+Rg;
                                                               countRegFP = countRegFP + 2;
                                                             }else{
                                                               Rg = "$s"+countReg;
                                                               TR = "MOVE"+" "+VAR+","+" "+Rg;
                                                               countReg++;
                                                             }
                                                             
                                                             rec.setRegister(Rg);                                                             
                                                             vTrad.add(TR);                                                             

                                                          }else{
                                                            
                                                             if(vard.tipo.equals("DOUBLE")){
                                                               Rg = "$f"+countRegFP;
                                                               TR = "MOVE.D"+" "+VAR+","+" "+Rg;
                                                               countRegFP = countRegFP + 2;
                                                             }else{
                                                               Rg = "$s"+countReg;
                                                               TR = "MOVE"+" "+VAR+","+" "+Rg;
                                                               countReg++;
                                                             }

                                                            rec.setRegister(Rg);
                                                            vTrad.add(TR);                                                         

                                                          }
                                                        }
                                                                                                              
                                                       TRAD = Traduzione.tradDecl(tipo.tipo, vard.testo);
                                                       
                                                       RESULT = new Obj(TRAD); 
                                                     :}
	|	FINAL type:tipo variable_declarators:vard   
                                                    {:                                                           
                                                      CheckClass.checkTypeA(tipo.tipo,vard.tipo,vard.testo);

                                                      if(checkFlag == true){                                                                                                                                                                   
                                                         parser.report_error(Err_War,vard);
                                                         checkFlag = false;
                                                         try{ wait(); }catch(Exception e){}
                                                      }

                                                      vard.testo = Support.getVar(vard.testo);
                                                      Record rec = SymbolTable.getCurrRec(vard.testo);
                                                      rec.setType(vard.tipo);
                                                      rec.setModifier("final");    
                                                                                                                       
                                                      RESULT = new Obj("final"+" "+tipo.testo+" "+vard.testo);                                                                                                                               
                                                     :}
	;

section_two ::= statement:stat {: 
                                 livP = 2; 
                                 RESULT = stat;
                               :}
        ;
                           /*COSTRUTTI DEL LINGUAGGIO JAVA*/
statement ::=	statement_without_trailing_substatement:swts {: RESULT = swts; :}
	|	if_then_statement:ifTstatm {: RESULT = ifTstatm; :}
	|	if_then_else_statement:ifTEstatm {: RESULT = ifTEstatm; :}
	|	while_statement:whstatm {: RESULT = whstatm; :}
	|	for_statement:fstatm {: RESULT = fstatm; :}
	;
statement_no_short_if ::=
		statement_without_trailing_substatement:swts {: RESULT = swts; :}
	|	if_then_else_statement_no_short_if:ifTEstatnosif {: RESULT = ifTEstatnosif; :}
	|	while_statement_no_short_if:whstatmnosif {: RESULT = whstatmnosif; :}
	|	for_statement_no_short_if:fstatmnosif {: RESULT = fstatmnosif; :}
	;
statement_without_trailing_substatement ::=
		block: bl {: RESULT = bl; :}
	|	empty_statement:emstatm {: RESULT = emstatm; :}
	|	expression_statement:esprstat {: RESULT = esprstat; :}	
	|	do_statement
	;
empty_statement ::=
		PUNTO_E_VIRGOLA {: RESULT = new Obj(";"); :}
	;
expression_statement ::=
		statement_expression:statespr PUNTO_E_VIRGOLA {: RESULT = statespr; :}
	;
statement_expression ::=
		assignment:ass {: RESULT = ass; :}
	|	postincrement_expression:postin {: RESULT = postin; :}
	|	postdecrement_expression:postde {: RESULT = postde; :}
	;

                              /*BLOCCO DI SELEZIONE IF*/
if_then_statement ::=
		IF TONDA_APERTA expression:espr TONDA_CHIUSA statement:statm {: 
                                                                          if(!espr.tipo.equals("BOOLEAN")){                                                                            
                                                                            parser.report_error("ERROR: il blocco di selezione accetta esclusivamente il tipo BOOLEAN!\n",espr);
                                                                            try{ wait(); }catch(Exception e){}
                                                                          } 
                                                                          if(espr.testo.contains(".D")){
                                                                              String esc = "ESCI"+countCl;
                                                                              espr.testo = espr.testo.concat(", "+esc);
                                                                              
                                                                              TRAD = espr.testo+"\n"+statm.testo+"\n"+esc+":\n";
                                                                              countCl++;
                                                                          }else{
                                                                              String esc = "ESCI"+countCl;
                                                                              espr.testo = espr.testo.replaceAll("OFFSET",esc);
                                                                          
                                                                              TRAD = espr.testo+"\n"+statm.testo+"\n"+esc+":\n";
                                                                              countCl++;
                                                                          }
                                                                          RESULT = new Obj(TRAD);   
                                                                        :}
	;
if_then_else_statement ::=
		IF TONDA_APERTA expression:espr TONDA_CHIUSA statement_no_short_if:statnosif 
			ELSE statement:statm {: 
                                            if(!espr.tipo.equals("BOOLEAN")){                                               
                                               parser.report_error("ERROR: il blocco di selezione accetta esclusivamente il tipo BOOLEAN!\n",espr);
                                               try{ wait(); }catch(Exception e){}
                                            } 

                                            if(espr.testo.contains(".D")){
                                                String el = "ELSE"+countCl;
                                                espr.testo = espr.testo.concat(", "+el);
                                                                              
                                                TRAD = espr.testo+"\n"+statnosif.testo+"\nj ESCI"+countCl+"\n"+el+": "+
                                                                                     statm.testo+"\nESCI"+countCl+":"+"\n";
                                                countCl++;
                                            }else{
                                               String el = "ELSE"+countCl;
                                               espr.testo = espr.testo.replaceAll("OFFSET",el);
 
                                               TRAD = espr.testo+"\n"+statnosif.testo+"\nj ESCI"+countCl+"\n"+el+": "+
                                                                                    statm.testo+"\nESCI"+countCl+":"+"\n";
                                               countCl++;
                                            }
                                                                                        
                                            RESULT = new Obj(TRAD);
                                          :}
	;
if_then_else_statement_no_short_if ::=
		IF TONDA_APERTA expression:espr TONDA_CHIUSA statement_no_short_if:statnosif1
			ELSE statement_no_short_if:statnosif2
                                          {: 
                                            if(!espr.tipo.equals("BOOLEAN")){                                               
                                               parser.report_error("ERROR: il blocco di selezione accetta esclusivamente il tipo BOOLEAN!\n",espr);
                                               try{ wait(); }catch(Exception e){}
                                            } 

                                            if(espr.testo.contains(".D")){
                                                String el = "ELSE"+countCl;
                                                espr.testo = espr.testo.concat(", "+el);
                                                                              
                                                TRAD = espr.testo+"\n"+statnosif1.testo+"\nj ESCI"+countCl+"\n"+el+": "+statnosif2.testo+"\nESCI:\n";
                                                countCl++;
                                            }else{
                                               String el = "ELSE"+countCl;
                                               espr.testo = espr.testo.replaceAll("OFFSET",el);
 
                                               TRAD = espr.testo+"\n"+statnosif1.testo+"\nj ESCI"+countCl+"\n"+el+": "+statnosif2.testo+"\nESCI:\n";
                                               countCl++;
                                            }

                                            
                                            RESULT = new Obj(TRAD);
                                          :}
	;

                                    /*CICLO WHILE*/
while_statement ::=
		WHILE TONDA_APERTA expression:espr TONDA_CHIUSA statement:statm 
                                       {: 
                                            if(!espr.tipo.equals("BOOLEAN")){                                               
                                               parser.report_error("ERROR: il ciclo WHILE accetta esclusivamente il tipo BOOLEAN!\n",espr);
                                               try{ wait(); }catch(Exception e){}
                                            } 

                                            if(espr.testo.contains(".D")){
                                                String esc = "ESCI"+countCl;
                                                espr.testo = espr.testo.concat(", "+esc);
                                                                              
                                                TRAD = "CICLO"+countCl+": "+"\t"+espr.testo+"\n"+statm.testo+"\nj CICLO"+countCl+"\n"+esc+":\n";
                                                countCl++;
                                            }else{
                                               String esc = "ESCI"+countCl;
                                               espr.testo = espr.testo.replaceAll("OFFSET",esc);
                                                                          
                                               TRAD = "CICLO"+countCl+": "+"\t"+espr.testo+"\n"+statm.testo+"\nj CICLO"+countCl+"\n"+esc+":\n";
                                               countCl++;
                                            }
                                                                 
                                            RESULT = new Obj(TRAD); 
                                          :}
	;
while_statement_no_short_if ::=
		WHILE TONDA_APERTA expression:espr TONDA_CHIUSA statement_no_short_if:statmnosif 
                                        {: 
                                            if(!espr.tipo.equals("BOOLEAN")){                                              
                                               parser.report_error("ERROR: il ciclo WHILE accetta esclusivamente il tipo BOOLEAN!",espr);
                                               try{ wait(); }catch(Exception e){}
                                            } 

                                            if(espr.testo.contains(".D")){
                                                String esc = "ESCI"+countCl;
                                                espr.testo = espr.testo.concat(", "+esc);
                                                                              
                                                TRAD = "CICLO"+countCl+": "+"\t"+espr.testo+"\n"+statmnosif.testo+"\nj CICLO"+countCl+"\n"+esc+":\n";
                                                countCl++;
                                            }else{
                                               String esc = "ESCI"+countCl;
                                               espr.testo = espr.testo.replaceAll("OFFSET",esc);
                                                                          
                                               TRAD = "CICLO"+countCl+": "+"\t"+espr.testo+"\n"+statmnosif.testo+"\nj CICLO"+countCl+"\n"+esc+":\n";
                                               countCl++; 
                                            }

                                                                        
                                            RESULT = new Obj(TRAD);
                                          :}
	;
do_statement ::=
		DO statement WHILE TONDA_APERTA expression:espr TONDA_CHIUSA PUNTO_E_VIRGOLA 
                                        /*{: 
                                            if(!espr.tipo.equals("BOOLEAN")){                                               
                                               parser.report_error("ERROR: il ciclo WHILE accetta esclusivamente il tipo BOOLEAN!\n",espr);
                                               try{ wait(); }catch(Exception e){}
                                            } 



                                          :}*/
	;

                                     /*CICLO FOR*/
for_statement ::=
		FOR TONDA_APERTA for_init_opt:fino PUNTO_E_VIRGOLA expression_opt:espr PUNTO_E_VIRGOLA
			for_update_opt:fupo TONDA_CHIUSA statement:statm

                                       {: 
                                            if(!espr.tipo.equals("BOOLEAN")){                                               
                                               parser.report_error("ERROR: il ciclo FOR accetta esclusivamente il tipo BOOLEAN!",fino);
                                               try{ wait(); }catch(Exception e){}
                                            } 

                                            if(espr.testo.contains(".D")){
                                                String esc = "ESCI"+countCl;
                                                espr.testo = espr.testo.concat(", "+esc);
                                                                              
                                                TRAD = fino.testo+"\n"+"CICLO"+countCl+": "+"\t"+espr.testo+"\n\t"+statm.testo+"\n\t"+fupo.testo+"\nj CICLO"+countCl+"\n"+esc+":\n";
                                                countCl++;
                                            }else{
                                               String esc = "ESCI"+countCl;
                                               espr.testo = espr.testo.replaceAll("OFFSET",esc);
                                                                          
                                               TRAD = fino.testo+"\n"+"CICLO"+countCl+": "+"\t"+espr.testo+"\n\t"+statm.testo+"\n\t"+fupo.testo+"\nj CICLO"+countCl+"\n"+esc+":\n";
                                               countCl++; 
                                            }
                                                                         
                                            RESULT = new Obj(TRAD);
                                          :}
	;
for_statement_no_short_if ::=
		FOR TONDA_APERTA for_init_opt:fino PUNTO_E_VIRGOLA expression_opt:espr PUNTO_E_VIRGOLA
			for_update_opt:fupo TONDA_CHIUSA statement_no_short_if:statmnosif
                                       {: 
                                            if(!espr.tipo.equals("BOOLEAN")){                                              
                                              parser.report_error("ERROR: il ciclo FOR accetta esclusivamente il tipo BOOLEAN!",fino);
                                              try{ wait(); }catch(Exception e){}
                                            } 

                                            if(espr.testo.contains(".D")){
                                                String esc = "ESCI"+countCl;
                                                espr.testo = espr.testo.concat(", "+esc);
                                                                              
                                                TRAD = fino.testo+"\n"+"CICLO"+countCl+": "+"\t"+espr.testo+"\n\t"+statmnosif.testo+"\n\t"+fupo.testo+"\nj CICLO"+countCl+"\n"+esc+":\n";
                                                countCl++;
                                            }else{
                                               String esc = "ESCI"+countCl;
                                               espr.testo = espr.testo.replaceAll("OFFSET",esc);
                                                                          
                                               TRAD = fino.testo+"\n"+"CICLO"+countCl+": "+"\t"+espr.testo+"\n\t"+statmnosif.testo+"\n\t"+fupo.testo+"\nj CICLO"+countCl+"\n"+esc+":\n";
                                               countCl++;  
                                            }
                                                                           
                                            RESULT = new Obj(TRAD);
                                        :}
	;
for_init_opt ::=
	 {: RESULT = new Obj(""); :}
        |	for_init:foriniz {: RESULT = foriniz; :}
	;
for_init ::=	statement_expression_list:stesprl {: RESULT = stesprl; :}
	|	local_variable_declaration:locvardec {: RESULT = locvardec; :}
	;
for_update_opt ::=
	 {: RESULT = new Obj(""); :}
        |	for_update:forup {: RESULT = forup; :}
	;
for_update ::=	statement_expression_list:stesprl {: RESULT = stesprl; :}
	;
statement_expression_list ::=
		statement_expression:stespr {: RESULT = stespr; :}
	|	statement_expression_list VIRGOLA statement_expression
	;

primary ::=	primary_no_new_array:pnna {: RESULT = pnna; :}
	|	array_creation_expression:arrcrespr {: RESULT = arrcrespr; :} 
	;
primary_no_new_array ::=
		literal:numero {: RESULT = numero; :}
	|	TONDA_APERTA expression:espr TONDA_CHIUSA {: RESULT = new Obj("( "+espr.testo+" )", espr.tipo); :}
	|	array_access:arracc {: 
                                      String T = "";
                                      if(arracc.tipo.equals("INTEGER")){
                                         T = "LW"; 
                                      }else if(arracc.tipo.equals("DOUBLE")){
                                         T = "L.D"; 
                                      }else{
                                         parser.report_error("ERROR: tipo non supportato!",arracc);
                                      }
                                      
                                      if(TabTrad.containsKey("ARRAY_ACCESS_I")){
                                         TRAD = T+" "+TabTrad.get("ARRAY_ACCESS_I");
                                         TabTrad.remove("ARRAY_ACCESS_I");
                                      }else if(TabTrad.containsKey("ARRAY_ACCESS")){
                                        
                                        TRAD = TabTrad.get("ARRAY_ACCESS");
                                          
                                        if(arracc.tipo.equals("DOUBLE")){
                                           TRAD = TRAD.replace(TRAD.substring(TRAD.lastIndexOf("\n$f")+1,TRAD.length()),
                                                  T+" "+TRAD.substring(TRAD.lastIndexOf("\n$f")+1,TRAD.length()));  
                                        }else{
                                           TRAD = TRAD.replace(TRAD.substring(TRAD.lastIndexOf("\n$t")+1,TRAD.length()),
                                                  T+" "+TRAD.substring(TRAD.lastIndexOf("\n$t")+1,TRAD.length()));
                                        }                                  
                                                                                
                                      } 
                                      
                                      RESULT = new Obj(TRAD,arracc.tipo,"ARRAY_ACCESS"); 
                             :}
	;

                            /*PARTE RIGUARDANTE GLI ARRAY*/
array_creation_expression ::=
		NEW primitive_type:primtype dim_exprs:essd dims_opt {: RESULT = new Obj("new "+primtype.testo+" "+essd.testo, primtype.tipo); :}
	|	NEW primitive_type dims array_initializer
	;
dim_exprs ::=	dim_expr:despr {: RESULT = despr; :}
	;
dim_expr ::=	LBRACK expression:espr RBRACK {: 
                                               if(!espr.tipo.equals("INTEGER")){                                                  
                                                  parser.report_error("ERROR: la dimensione del vettore deve essere un numero intero!\n",espr);
                                                  try{ wait(); }catch(Exception e){}
                                               }else{  
                                                   RESULT = new Obj("["+espr.testo+"]",espr.tipo);
                                               }
                                              :}
	;
dims_opt ::=
        {: RESULT = new Obj(""); :}
	|	dims:d 
	;
dims ::=	LBRACK RBRACK {: RESULT = new Obj("["+"]"); :}
	|	dims LBRACK RBRACK
	;

array_access ::=
		name:nome LBRACK expression:espr RBRACK {:
                                                         int I1,I2;
                                                         Record rec = SymbolTable.checkVScope(nome.testo);

                                                         if(checkFlag == true){                                                                                                                                                                                                                                   
                                                              parser.report_error(Err_War,nome);
                                                              checkFlag = false;
                                                              try{ wait(); }catch(Exception e){}
                                                         }
   
                                                         nome.tipo = rec.getType();
                                                         
                                                         if(!espr.tipo.equals("INTEGER")){                                                           
                                                            parser.report_error("ERROR: la dimensione del vettore deve essere un numero intero!\n",espr);
                                                            try{ wait(); }catch(Exception e){}
                                                         }else{  
                                                             
                                                             if(espr.genere.equals("NUMERO")){
                                                                I1 = Support.changeStrInt(espr.testo);
                                                                I2 = Support.changeStrInt(rec.getValue().toString());
                                                            
                                                             }else{
                                                                    Record recE = SymbolTable.getCurrRec(espr.testo);
                                                                    
                                                                    I1 = Support.changeStrInt(recE.getValue().toString());
                                                                    I2 = Support.changeStrInt(rec.getValue().toString());                                                                    
                                                             }                                            
                                                        
                                                          if(I1 > I2){                                                                                                                             
                                                                  parser.report_error("ERROR: l'indice supera la dimensione massima del vettore!\n",espr);
                                                                  try{ wait(); }catch(Exception e){}
                                                                } 
                                                         }
                                                        
                                                         if(espr.genere.equals("NUMERO")){

                                                           if(nome.tipo.equals("DOUBLE")){
                                                              TRAD = "$f"+countRegFP+", "+Support.calcOffset(espr.testo,nome.tipo)+
                                                                                                              "("+rec.getRegister()+")";
                                                              TabTrad.put("ARRAY_ACCESS_I",TRAD);
                                                              countRegFP = countRegFP + 2;
                                                           }else{
                                                              TRAD = "$t"+countRTemp+", "+Support.calcOffset(espr.testo,nome.tipo)+
                                                                                                              "("+rec.getRegister()+")";
                                                              TabTrad.put("ARRAY_ACCESS_I",TRAD);
                                                              countRTemp++;
                                                           } 
                                                                                                                      
                                                          }else if(espr.genere.equals("VARIABILE")){
                                                            Record recE = SymbolTable.getCurrRec(espr.testo);
                                                            
                                                            
                                                            if(nome.tipo.equals("INTEGER")){
                                                              
                                                            int countRTempS = countRTemp+1;
                                                            TRAD = "MULT "+"$t"+countRTempS+", "+recE.getRegister()+", "+4+"\n"+
                                                                   "ADD "+"$t"+countRTempS+", "+"$t"+countRTempS+", "+rec.getRegister()+"\n"+
                                                                   "$t"+countRTemp+", "+"0("+"$t"+countRTempS+")";
                                                            TabTrad.put("ARRAY_ACCESS",TRAD);
                                                            countRTemp = countRTemp+2;
                                                            }else if(nome.tipo.equals("DOUBLE")){
                                                             
                                                            TRAD = "MULT "+"$t"+countRTemp+", "+recE.getRegister()+", "+8+"\n"+
                                                                   "MTC1 "+"$t"+countRTemp+", "+"$f"+countRegFP+"\n"+ 
                                                                   "ADD.D "+"$f"+countRegFP+", "+"$f"+countRegFP+", "+rec.getRegister()+"\n"+
                                                                   "TEMP"+", "+"0("+"$f"+countRegFP+")";
                                                            countRegFP = countRegFP + 2;
                                                            TRAD = TRAD.replace("TEMP","$f"+Integer.toString(countRegFP));
                                                            TabTrad.put("ARRAY_ACCESS",TRAD);
                                                            countRTemp++;
                                                            countRegFP = countRegFP + 2;
                                                            }else{                                                               
                                                              parser.report_error("ERROR: tipo non supportato!\n",espr); 
                                                              try{ wait(); }catch(Exception e){}
                                                            }
                                                            
                                                            espr.genere = "";
                                                          }else{                                                              
                                                              parser.report_error("ERROR!",espr);
                                                              try{ wait(); }catch(Exception e){}
                                                          }
                                                                                                             
                                                        RESULT = new Obj(nome.testo+"["+espr.testo+"]", nome.tipo,espr.genere);
                                                       :}
	;
postfix_expression ::=
		primary:prim {: RESULT = prim; :}
	|	name:nome {:  
                             Record rec = SymbolTable.checkVScope(nome.testo);

                             if(checkFlag == true){                                                                                                                                                                                                      
                                parser.report_error(Err_War,nome);
                                checkFlag = false;
                                try{ wait(); }catch(Exception e){}
                             }
  
                             nome.tipo = rec.getType();
                             
                             RESULT = new Obj(nome.testo,nome.tipo,"VARIABILE"); 
                          :} 
	|	postincrement_expression:postinespr {: RESULT = postinespr; :}
	|	postdecrement_expression:postdecespr {: RESULT = postdecespr; :}
	;

postincrement_expression ::=
		postfix_expression:postespr PLUSPLUS {: 
                                               if(!postespr.tipo.equals("INTEGER")){                                                   
                                                    parser.report_error("ERROR: il tipo di tale variabile deve essere necessariamente intero!\n",postespr);
                                                    try{ wait(); }catch(Exception e){}
                                                } 
                                                
                                                Record rec = SymbolTable.getCurrRec(postespr.testo);   
                                                TRAD = "ADDI"+" "+rec.getRegister()+", "+rec.getRegister()+", "+"1";

                                               RESULT = new Obj(TRAD,postespr.tipo);
                                            :}             
                            
	;
postdecrement_expression ::=
		postfix_expression:postespr MINUSMINUS {: 
                                                 if(!postespr.tipo.equals("INTEGER")){                                                    
                                                    parser.report_error("ERROR: il tipo di tale variabile deve essere necessariamente intero!\n",postespr);
                                                    try{ wait(); }catch(Exception e){}
                                                 } 
                                                   
                                                Record rec = SymbolTable.getCurrRec(postespr.testo);   
                                                TRAD = "ADDI"+" "+rec.getRegister()+", "+rec.getRegister()+", "+"-1";

                                                RESULT = new Obj(TRAD,postespr.tipo);
                                               :}
	;

unary_expression ::=
	unary_expression_not_plus_minus:uenpm {: RESULT = uenpm; :}
	;

unary_expression_not_plus_minus ::=
		postfix_expression:postex {: RESULT = postex; :}
	|	cast_expression
	;

                                  /*CAST DI UNA VARIABILE */
cast_expression ::=
		TONDA_APERTA primitive_type:primtype dims_opt TONDA_CHIUSA unary_expression:unespr
                                                                                 /*{: 
                                                                                      if(primtype.tipo.equals("BOOLEAN") && !enespr.tipo.equals(BOOLEAN)){
                                                                                      
                                                                                         parser.report_error("Error: non  possibile effettuare il cast!!!\n",unespr);

                                                                                      }else{                                                                                                                                                                           
                                                                                       RESULT = new Obj();
                                                                                      }
                                                                                      
                                                                                    :}*/
	;

                   /*ESPRESSIONI CON OPERAZIONI DI MOLTIPLICAZIONE E DIVISIONE*/
multiplicative_expression ::=
		unary_expression:unex {: RESULT = unex; :}
	|	multiplicative_expression:multespr PER unary_expression:unex {:  String mlT = CheckClass.checkTypeMD(multespr.tipo,unex.tipo); 

                                                                                  if(checkFlag == true){                                                                                                                                                                                                                                                         
                                                                                    parser.report_error(Err_War,multespr);
                                                                                    checkFlag = false;
                                                                                    try{ wait(); }catch(Exception e){}
                                                                                  }

                                                                                  if(flagWarn == true){
                                                                                     Traduzione.castFP(multespr.tipo,multespr.genere,multespr.testo,unex.genere,unex.testo);
                                                                                     TRAD = Traduzione.tradEspr(1,multespr.genere, unex.genere,
                                                                                                             multespr.testo,unex.testo,mlT);
                                                                                     
                                                                                     parser.warning(Err_War,multespr);
                                                                                     flagWarn = false;
                                                                                  }else{
                                                                                     if(mlT.equals("DOUBLE")){
                                                                                        TRAD = Traduzione.tradEspr(multespr.genere, unex.genere,
                                                                                                                      multespr.testo,unex.testo,mlT,1);
                                                                                     }else{
                                                                                        TRAD = Traduzione.tradEspr(multespr.genere, unex.genere,
                                                                                                                      multespr.testo,unex.testo,1,mlT);
                                                                                     }
                                                                                  }
                                                                                                                               
                                                                                  RESULT = new Obj(TRAD,mlT,"ESPRESSIONE"); 
                                                                                 :}
	|	multiplicative_expression:multespr DIVISO unary_expression:unex {: 
                                                                                   if(Integer.parseInt(unex.testo) == 0){                                                                                      
                                                                                      parser.report_error("ERROR: non e' possibile effettuare la divisione per 0!\n",multespr);
                                                                                      try{ wait(); }catch(Exception e){}
                                                                                   }

                                                                                   String dvT = CheckClass.checkTypeMD(multespr.tipo,unex.tipo); 
                                                                                     
                                                                                   if(checkFlag == true){                                                                                                                                                                      
                                                                                    parser.report_error(Err_War,multespr);
                                                                                    checkFlag = false;
                                                                                    try{ wait(); }catch(Exception e){}
                                                                                  }

                                                                                   if(flagWarn == true){
                                                                                     Traduzione.castFP(multespr.tipo,multespr.genere,multespr.testo,unex.genere,unex.testo);
                                                                                     TRAD = Traduzione.tradEspr(2,multespr.genere, unex.genere,
                                                                                                             multespr.testo,unex.testo,dvT);
                                                                                     parser.warning(Err_War,multespr);
                                                                                     flagWarn = false;
                                                                                   }else{
                                                                                     if(dvT.equals("DOUBLE")){
                                                                                        TRAD = Traduzione.tradEspr(multespr.genere, unex.genere,
                                                                                                                      multespr.testo,unex.testo,dvT,2);
                                                                                     }else{
                                                                                        TRAD = Traduzione.tradEspr(multespr.genere, unex.genere,
                                                                                                                      multespr.testo,unex.testo,2,dvT);
                                                                                     }
                                                                                   }
                                                                                                                                                                         
                                                                                   RESULT = new Obj(TRAD,dvT,"ESPRESSIONE");
                                                                                  
                                                                                  :}
	;

                        /*ESPRESSIONI CON OPERAZIONI DI SOMMA E DIFFERENZA*/
additive_expression ::=
		multiplicative_expression:multex {: RESULT = multex; :}
	|	additive_expression:addespr PIU multiplicative_expression:multespr {: String smT = CheckClass.checkTypeMD(addespr.tipo,multespr.tipo); 
                                                                                      
                                                                                      if(checkFlag == true){                                                                                                                                                                   
                                                                                         parser.report_error(Err_War,multespr);
                                                                                         checkFlag = false;
                                                                                         try{ wait(); }catch(Exception e){}
                                                                                      }

                                                                                      if(flagWarn == true){
                                                                                         Traduzione.castFP(addespr.tipo,addespr.genere,addespr.testo,multespr.genere,multespr.testo);
                                                                                         TRAD = Traduzione.tradEspr(3,addespr.genere, multespr.genere,
                                                                                                             addespr.testo,multespr.testo,smT);
                                                                                         parser.warning(Err_War,multespr);
                                                                                         flagWarn = false;
                                                                                      }else{
                                                                                         if(smT.equals("DOUBLE")){
                                                                                            TRAD = Traduzione.tradEspr(addespr.genere,multespr.genere,
                                                                                                                      addespr.testo,multespr.testo,smT,3);
                                                                                         }else{
                                                                                            TRAD = Traduzione.tradEspr(addespr.genere,multespr.genere,
                                                                                                                       addespr.testo,multespr.testo,3,smT);
                                                                                         }
                                                                                      }
                                                                                                                                                                 
                                                                                      RESULT = new Obj(TRAD,smT,"ESPRESSIONE");
                                                                                    :}
	|	additive_expression:addespr MENO multiplicative_expression:multespr {: String dfT = CheckClass.checkTypeMD(addespr.tipo,multespr.tipo); 
                                                                                       
                                                                                       if(checkFlag == true){                                                                                                                                                                  
                                                                                         parser.report_error(Err_War,multespr);
                                                                                         checkFlag = false;
                                                                                         try{ wait(); }catch(Exception e){}
                                                                                       }

                                                                                       if(flagWarn == true){
                                                                                         Traduzione.castFP(addespr.tipo,addespr.genere,addespr.testo,multespr.genere,multespr.testo);
                                                                                         TRAD = Traduzione.tradEspr(4,addespr.genere, multespr.genere,
                                                                                                             addespr.testo,multespr.testo,dfT);
                                                                                         parser.warning(Err_War,multespr);                                                                                        
                                                                                         flagWarn = false;
                                                                                       }else{
                                                                                         if(dfT.equals("DOUBLE")){
                                                                                            TRAD = Traduzione.tradEspr(addespr.genere,multespr.genere,
                                                                                                                      addespr.testo,multespr.testo,dfT,4);
                                                                                         }else{
                                                                                            TRAD = Traduzione.tradEspr(addespr.genere,multespr.genere,
                                                                                                                       addespr.testo,multespr.testo,4,dfT);
                                                                                         }
                                                                                       }
                                                                                                                                                                              
                                                                                      RESULT = new Obj(TRAD,dfT,"ESPRESSIONE");
                                                                                    :}
	;

                                 /*SEZIONE RIGUARDANTE LE CONDIZIONI <, >, <=, >=*/
relational_expression ::=
		additive_expression:addespr {: RESULT = addespr; :}
	|	relational_expression:relespr LT additive_expression:addespr {:CheckClass.checkOpCond(relespr.tipo,addespr.tipo); 

                                                                               if(checkFlag == true){                                                                                                                                                                    
                                                                                    parser.report_error(Err_War,relespr);
                                                                                    checkFlag = false;
                                                                                    try{ wait(); }catch(Exception e){}
                                                                                }

                                                                               if(relespr.tipo.equals("INTEGER") && addespr.tipo.equals("INTEGER")){
                                                                                  String RTemp = "$t"+countRTemp;
                                                                                  TRAD = Traduzione.tradRel(relespr.genere,addespr.genere,
                                                                                                             relespr.testo,addespr.testo,RTemp,1,relespr.tipo,addespr.tipo);
                                                                                  countRTemp++;
                                                                               }else if(relespr.tipo.equals("DOUBLE") && addespr.tipo.equals("DOUBLE")){
                                                                                  TRAD = Traduzione.tradRel(relespr.genere,addespr.genere,
                                                                                                             relespr.testo,addespr.testo,2,relespr.tipo);          
                                                                               }else{
                                                                                  TRAD = Traduzione.tradRel(relespr.genere,addespr.genere,
                                                                                                  relespr.testo,addespr.testo,relespr.tipo,addespr.tipo,2); 
                                                                               } 
                                                                               
                                                                               RESULT = new Obj(TRAD,"BOOLEAN");  
                                                                              :}
	|	relational_expression:relespr GT additive_expression:addespr {: 
                                                                                CheckClass.checkOpCond(relespr.tipo,addespr.tipo);
                                                                                
                                                                                if(checkFlag == true){                                                                                                                                                                     
                                                                                    parser.report_error(Err_War,relespr);
                                                                                    checkFlag = false;
                                                                                    try{ wait(); }catch(Exception e){}
                                                                                }

                                                                                if(relespr.tipo.equals("INTEGER") && addespr.tipo.equals("INTEGER")){
                                                                                  String RTemp = "$t"+countRTemp;
                                                                                  TRAD = Traduzione.tradRel(relespr.genere,addespr.genere,
                                                                                                             relespr.testo,addespr.testo,RTemp,2,relespr.tipo,addespr.tipo);
                                                                                  countRTemp++;
                                                                                }else if(relespr.tipo.equals("DOUBLE") && addespr.tipo.equals("DOUBLE")){
                                                                                  TRAD = Traduzione.tradRel(relespr.genere,addespr.genere,
                                                                                                             relespr.testo,addespr.testo,1,relespr.tipo);          
                                                                                }else{
                                                                                  TRAD = Traduzione.tradRel(relespr.genere,addespr.genere,
                                                                                                  relespr.testo,addespr.testo,relespr.tipo,addespr.tipo,1); 
                                                                                } 
                                                                                
                                                                                RESULT = new Obj(TRAD,"BOOLEAN"); 
                                                                              :} 
	|	relational_expression:relespr LTEQ additive_expression:addespr {:
                                                                                CheckClass.checkOpCond(relespr.tipo,addespr.tipo);

                                                                                if(checkFlag == true){                                                                                                                                                                   
                                                                                    parser.report_error(Err_War,relespr);
                                                                                    checkFlag = false;
                                                                                    try{ wait(); }catch(Exception e){}
                                                                                }

                                                                                if(relespr.tipo.equals("INTEGER") && addespr.tipo.equals("INTEGER")){
                                                                                  String RTemp = "$t"+countRTemp;
                                                                                  TRAD = Traduzione.tradRel(relespr.genere,addespr.genere,
                                                                                                             relespr.testo,addespr.testo,RTemp,3,relespr.tipo,addespr.tipo);
                                                                                  countRTemp++;
                                                                                }else if(relespr.tipo.equals("DOUBLE") && addespr.tipo.equals("DOUBLE")){
                                                                                  TRAD = Traduzione.tradRel(relespr.genere,addespr.genere,
                                                                                                             relespr.testo,addespr.testo,4,relespr.tipo);          
                                                                                }else{
                                                                                  TRAD = Traduzione.tradRel(relespr.genere,addespr.genere,
                                                                                                  relespr.testo,addespr.testo,relespr.tipo,addespr.tipo,4); 
                                                                                } 
                                                                               
                                                                                RESULT = new Obj(TRAD,"BOOLEAN");   
                                                                                :}
	|	relational_expression:relespr GTEQ additive_expression:addespr {: 
                                                                                CheckClass.checkOpCond(relespr.tipo,addespr.tipo);
                                                                                
                                                                                if(checkFlag == true){                                                                                                                                                                    
                                                                                    parser.report_error(Err_War,relespr);
                                                                                    checkFlag = false;
                                                                                    try{ wait(); }catch(Exception e){}
                                                                                }

                                                                                if(relespr.tipo.equals("INTEGER") && addespr.tipo.equals("INTEGER")){
                                                                                  String RTemp = "$t"+countRTemp;
                                                                                  TRAD = Traduzione.tradRel(relespr.genere,addespr.genere,
                                                                                                             relespr.testo,addespr.testo,RTemp,4,relespr.tipo,addespr.tipo);
                                                                                  countRTemp++;
                                                                                }else if(relespr.tipo.equals("DOUBLE") && addespr.tipo.equals("DOUBLE")){
                                                                                  TRAD = Traduzione.tradRel(relespr.genere,addespr.genere,
                                                                                                             relespr.testo,addespr.testo,3,relespr.tipo);          
                                                                                }else{
                                                                                  TRAD = Traduzione.tradRel(relespr.genere,addespr.genere,
                                                                                                  relespr.testo,addespr.testo,relespr.tipo,addespr.tipo,3); 
                                                                                } 
                                                                                
                                                                                RESULT = new Obj(TRAD,"BOOLEAN"); 
                                                                                :}
	;

                              /*SEZIONE RIGUARDANTE LE CONDIZIONI  ==, != */
equality_expression ::=
		relational_expression:relex {: RESULT = relex; :}
	|	equality_expression:eqespr EQEQ relational_expression:relespr {: 
                                                                                CheckClass.checkEQNEQ(eqespr.tipo,relespr.tipo); 

                                                                                if(checkFlag == true){                                                                                                                                                                     
                                                                                    parser.report_error(Err_War,relespr);
                                                                                    checkFlag = false;
                                                                                    try{ wait(); }catch(Exception e){}
                                                                                }

                                                                                if(eqespr.tipo.equals("INTEGER") && relespr.tipo.equals("INTEGER")){
                                                                                    TRAD = Traduzione.tradEQNEQ(eqespr.genere,relespr.genere,
                                                                                                                     eqespr.testo,relespr.testo,eqespr.tipo,relespr.tipo,1);
                                                                                }else if(eqespr.tipo.equals("DOUBLE") && relespr.tipo.equals("DOUBLE")){
                                                                                    TRAD = Traduzione.tradEQNEQ(eqespr.genere,relespr.genere,
                                                                                                                     eqespr.testo,relespr.testo,eqespr.tipo,relespr.tipo,1);
                                                                                }else{
                                                                                    TRAD = Traduzione.tradEQNEQFPI(eqespr.genere,relespr.genere,
                                                                                                 eqespr.testo,relespr.testo,eqespr.tipo,relespr.tipo,1);
                                                                                }
                                                                                 
                                                                                RESULT = new Obj(TRAD,"BOOLEAN"); 
                                                                              :}
	|	equality_expression:eqespr NOTEQ relational_expression:relespr {: 
                                                                                CheckClass.checkEQNEQ(eqespr.tipo,relespr.tipo);

                                                                                if(checkFlag == true){                                                                                                                                                                     
                                                                                    parser.report_error(Err_War,relespr);
                                                                                    checkFlag = false;
                                                                                    try{ wait(); }catch(Exception e){}
                                                                                }

                                                                                if(eqespr.tipo.equals("INTEGER") && relespr.tipo.equals("INTEGER")){
                                                                                    TRAD = Traduzione.tradEQNEQ(eqespr.genere,relespr.genere,
                                                                                                                     eqespr.testo,relespr.testo,eqespr.tipo,relespr.tipo,2);
                                                                                }else if(eqespr.tipo.equals("DOUBLE") && relespr.tipo.equals("DOUBLE")){
                                                                                    TRAD = Traduzione.tradEQNEQ(eqespr.genere,relespr.genere,
                                                                                                                     eqespr.testo,relespr.testo,eqespr.tipo,relespr.tipo,2);
                                                                                }else{
                                                                                    TRAD = Traduzione.tradEQNEQFPI(eqespr.genere,relespr.genere,
                                                                                                 eqespr.testo,relespr.testo,eqespr.tipo,relespr.tipo,2);
                                                                                }
    
                                                                                 RESULT = new Obj(TRAD,"BOOLEAN");  
                                                                                :}
	;

conditional_and_expression ::=
		equality_expression:eqex {: RESULT = eqex; :}
	|	conditional_and_expression ANDAND equality_expression:eqex
	;
conditional_or_expression ::=
		conditional_and_expression:condandex {: RESULT = condandex; :}
	|	conditional_or_expression OROR conditional_and_expression
	;
assignment_expression ::=
		conditional_or_expression:condorex {: RESULT = condorex; :}  
	|	assignment:ass {: RESULT = ass; :}
	;
                    
                                   /*ASSEGNAZIONE AD UNA VARIABILE*/
assignment ::=	left_hand_side:lhs EQ assignment_expression:assespr  {:                                                                                                                                                                              
                                                                       if(lhs.testo.contains("[") && lhs.testo.contains("]")){
                                                                                               
                                                                         String var = lhs.testo.substring(0,lhs.testo.indexOf("["));
                                                                                                
                                                                         Record rec = SymbolTable.getCurrRec(var);

                                                                         int n1 = lhs.testo.indexOf("[");
                                                                         int n2 = lhs.testo.indexOf("]");
                                                                                                
                                                                         String num = lhs.testo.substring(n1+1,n2);
                                                                                                                                                                                        
                                                                         CheckClass.checkTypeA(lhs.tipo,assespr.tipo,assespr.testo);
                                                                         if(checkFlag == true){                                                                                                                                                                      
                                                                                    parser.report_error(Err_War,lhs);
                                                                                    checkFlag = false;
                                                                                    try{ wait(); }catch(Exception e){}
                                                                                }
                                                                         
                                                                                                
                                                                         if(lhs.genere.equals("ARRAY_ACCESS_I")){                                                                                                  
                                                                             int ind = Support.changeStrInt(num);
                                                                             boolean fg = rec.setArrayList(assespr.testo, ind);

                                                                             if(flagWarn == true){                                                                                                                                                                        
                                                                                    parser.warning(Err_War,lhs);
                                                                                    flagWarn = false;
                                                                             }
  
                                                                             if(fg==true){
                                                                                rec.remElem(ind+1);
                                                                             }
                                                                         }

                                                                          String UT;
                                                                          int l;
                                                                          if(lhs.tipo.equals("DOUBLE")){
                                                                             lhs.testo = TabTrad.get("ARRAY_ACCESS_ASS");
                                                                             l = lhs.testo.lastIndexOf(" $f");
                                                                             UT = lhs.testo.substring(l+1,l+4); 
                                                                          }else{
                                                                             lhs.testo = TabTrad.get("ARRAY_ACCESS_ASS");
                                                                             l = lhs.testo.lastIndexOf(" $t");
                                                                             UT = lhs.testo.substring(l+1,l+4); 
                                                                          }                   
                                                                                                                                                 
                                                                         if(flagWarn == true){
                                                                                parser.warning(Err_War,lhs);

                                                                                String APP = Traduzione.funct(assespr.genere,assespr.testo);
                                                                                if(assespr.genere.equals("ESPRESSIONE")){                                                                                                           
                                                                                    assespr.testo = assespr.testo.replace("RIS",UT);                               
                                                                                     int nh = lhs.testo.lastIndexOf("S");
                                                                                     TRAD = lhs.testo.substring(0,nh)+assespr.testo+"\n"+lhs.testo.substring(nh,lhs.testo.length());                                                              
                                                                                }else if (assespr.genere.equals("ARRAY_ACCESS")){                                            
                                                                                    TRAD = lhs.testo.substring(0,l-3)+assespr.testo+"\n"+APP+lhs.testo.substring(l-3,lhs.testo.length()).replace(UT,Traduzione.getRegFP()); 
                                                                                }else{
                                                                                    TRAD = lhs.testo.substring(0,l-3)+"\n"+APP+lhs.testo.substring(l-3,lhs.testo.length()).replace(UT,Traduzione.getRegFP()); 
                                                                                }

                                                                             flagWarn = false;  
                                                                         }else{
                                                                            
                                                                              if(lhs.tipo.equals("INTEGER")){

                                                                                if(assespr.genere.equals("ESPRESSIONE")){
                                                                                                     
                                                                                  assespr.testo = assespr.testo.replace("RIS",UT);
                                                                                  int nh = lhs.testo.lastIndexOf("S");
                                                                                  TRAD = lhs.testo.substring(0,nh)+assespr.testo+"\n"+lhs.testo.substring(nh,lhs.testo.length());
                                                                                                
                                                                                }else if(assespr.genere.equals("VARIABILE")){
                                                                                                     
                                                                                  Record rec2 = SymbolTable.getCurrRec(assespr.testo);
                                                                                  TRAD = lhs.testo.substring(0,l-2)+lhs.testo.substring(l-2,lhs.testo.length()).replace(UT,rec2.getRegister());
                                                                                                
                                                                                }else if(assespr.genere.equals("ARRAY_ACCESS")){
                                                                                                     
                                                                                  int m = assespr.testo.lastIndexOf(" $t");
                                                                                  String MT = assespr.testo.substring(m+1,m+4);
                                                                                  TRAD = lhs.testo.substring(0,l-2)+assespr.testo+"\n"+lhs.testo.substring(l-2,lhs.testo.length()).replace(UT,MT);
                                                                         
                                                                                }else{

                                                                                 TRAD = lhs.testo.replace(UT,assespr.testo);
                                                                                }

                                                                              }else{

                                                                                if(assespr.genere.equals("ESPRESSIONE")){
                                                                                                     
                                                                                  assespr.testo = assespr.testo.replace("RIS",UT);
                                                                                  int nh = lhs.testo.lastIndexOf("S");
                                                                                  TRAD = lhs.testo.substring(0,nh)+assespr.testo+"\n"+lhs.testo.substring(nh,lhs.testo.length());
                                                                                                
                                                                             }else if(assespr.genere.equals("VARIABILE")){
                                                                                                     
                                                                                  Record rec2 = SymbolTable.getCurrRec(assespr.testo);
                                                                                  TRAD = lhs.testo.substring(0,l-2)+lhs.testo.substring(l-2,lhs.testo.length()).replace(UT,rec2.getRegister());
                                                                                                
                                                                             }else if(assespr.genere.equals("ARRAY_ACCESS")){
                                                                                                     
                                                                                  int m = assespr.testo.lastIndexOf(" $f");
                                                                                  String MT = assespr.testo.substring(m+1,m+4);
                                                                                  TRAD = lhs.testo.substring(0,l-2)+assespr.testo+"\n"+lhs.testo.substring(l-2,lhs.testo.length()).replace(UT,MT);
                                                                         
                                                                             }else{

                                                                                 TRAD = lhs.testo.replace(UT,assespr.testo);
                                                                             }

                                                                              }                                                                             

                                                                         }
                                                          
                                                                      }else{
                                                                                                  
                                                                          Record rec = SymbolTable.getCurrRec(lhs.testo);
                                                                       
                                                                          if(rec.getModifier().equals("null")){
                                                                                                    
                                                                            String str = CheckClass.checkTypeA(lhs.tipo,assespr.tipo,assespr.testo);

                                                                            if(checkFlag == true){                                                                                                                                                                       
                                                                                    parser.report_error(Err_War,lhs);
                                                                                    checkFlag = false;
                                                                                    try{ wait(); }catch(Exception e){}
                                                                            }

                                                                            if(flagWarn == true){
                                                                                parser.warning(Err_War,lhs);

                                                                                String APP = Traduzione.funct(assespr.genere,assespr.testo);
                                                                                if(assespr.genere.equals("ESPRESSIONE")){                                                                                                           
                                                                                   // T.substring(T.indexOf("RIS")-4, T.indexOf("RIS"));
                                                                                   // TRAD = APP. 
                                                                                   // TRAD = APP.replace("RIS",rec.getRegister());                              
                                                                                                                                                                                                                                        
                                                                                }else if (assespr.genere.equals("ARRAY_ACCESS")){                                            
                                                                                     TRAD = assespr.testo+"\n"+APP+Traduzione.OpEspr(3,rec.getType())+" "+
                                                                                                       rec.getRegister()+", $zero"+", "+Traduzione.getRegFP();
                                                                                }else{
                                                                                     TRAD = APP+Traduzione.OpEspr(3,rec.getType())+" "+rec.getRegister()+
                                                                                                                    ", $zero"+", "+Traduzione.getRegFP();
                                                                                }
                                                                               flagWarn = false;
                                                                            }else{
                                                                                if(lhs.tipo.equals("INTEGER")){

                                                                                     if(assespr.genere.equals("ESPRESSIONE")){                                                                                                           
                                                                                          TRAD = assespr.testo.replace("RIS",rec.getRegister());                              
                                                                                     }else if (assespr.genere.equals("VARIABILE")){
                                                                                          Record rec2 = SymbolTable.getCurrRec(assespr.testo);
                                                                                          TRAD = Traduzione.OpEspr(3,rec.getType())+" "+rec.getRegister()+
                                                                                                                          ", $zero"+", "+rec2.getRegister();
                                                                                     }else if (assespr.genere.equals("ARRAY_ACCESS")){                                                                               
                                                                                          int l = assespr.testo.lastIndexOf(" $t");
                                                                                          String UT = assespr.testo.substring(l+1,l+4);
                                                                                          TRAD = assespr.testo+"\n"+Traduzione.OpEspr(3,rec.getType())+" "+
                                                                                                                          rec.getRegister()+", $zero"+", "+UT;
                                                                                     }else{
                                                                                          rec.setValue(assespr.testo);
                                                                                          TRAD = Traduzione.OpEspr(3,rec.getType())+"I"+" "+rec.getRegister()+
                                                                                                                                  ", $zero"+", "+assespr.testo;
                                                                                     }

                                                                                 }else{

                                                                                     if(assespr.genere.equals("ESPRESSIONE")){                                                                                                           
                                                                                          TRAD = assespr.testo.replace("RIS",rec.getRegister());                              
                                                                                     }else if (assespr.genere.equals("VARIABILE")){
                                                                                          Record rec2 = SymbolTable.getCurrRec(assespr.testo);
                                                                                          TRAD = Traduzione.OpEspr(3,rec.getType())+" "+rec.getRegister()+
                                                                                                                          ", $zero"+", "+rec2.getRegister();
                                                                                     }else if (assespr.genere.equals("ARRAY_ACCESS")){                                                                               
                                                                                          int l = assespr.testo.lastIndexOf(" $f");
                                                                                          String UT = assespr.testo.substring(l+1,l+4);
                                                                                          TRAD = assespr.testo+"\n"+Traduzione.OpEspr(3,rec.getType())+" "+
                                                                                                                          rec.getRegister()+", $zero"+", "+UT;
                                                                                     }else{
                                                                                          rec.setValue(assespr.testo);
                                                                                          TRAD = Traduzione.OpEspr(3,rec.getType())+"I"+" "+rec.getRegister()+
                                                                                                                                  ", $zero"+", "+assespr.testo;
                                                                                     }

                                                                                 }
                                                                            }                          
                                                                            
                                                                         }else{                                                                           
                                                                            parser.report_error("ERROR: non e' possibile assegnare un valore ad una variabile con modificatore final!!!!\n",lhs);
                                                                            try{ wait(); }catch(Exception e){}
                                                                         }
                                                                                
                                                                     }                                                                                                                                                                         
                                                                                              
                                                                         RESULT = new Obj(TRAD,lhs.tipo);                                                                                           
                                                                    :}
	;

left_hand_side ::=
		name:nome {: 
                            Record rec = SymbolTable.checkVScope(nome.testo); 

                            if(checkFlag == true){                                                                                                                                                                    
                                parser.report_error(Err_War,nome);
                                checkFlag = false;
                                try{ wait(); }catch(Exception e){}
                            }
                           
                            nome.tipo = rec.getType();
                                                        
                            RESULT = new Obj(nome.testo,nome.tipo,"VARIABILE"); 
                           :}
	|	array_access:arracc {:
                                      String T = "";
                                      if(arracc.tipo.equals("INTEGER")){
                                         T = "SW"; 
                                      }else if(arracc.tipo.equals("DOUBLE")){
                                         T = "S.D"; 
                                      }else{
                                         parser.report_error("ERROR: tipo non supportato!",arracc);
                                         try{ wait(); }catch(Exception e){}
                                      }
                                      
                                      if(TabTrad.containsKey("ARRAY_ACCESS_I")){
                                         
                                         TRAD = T+" "+TabTrad.get("ARRAY_ACCESS_I");
                                         
                                         TabTrad.put("ARRAY_ACCESS_ASS",TRAD);
                                         TabTrad.remove("ARRAY_ACCESS_I");
                                         
                                         arracc.genere = "ARRAY_ACCESS_I";

                                      }else if(TabTrad.containsKey("ARRAY_ACCESS")){
                                        
                                        TRAD = TabTrad.get("ARRAY_ACCESS");
                                        if(arracc.tipo.equals("DOUBLE")){
                                            TRAD = TRAD.replace(TRAD.substring(TRAD.lastIndexOf("\n$f")+1,TRAD.length()),
                                                          T+" "+TRAD.substring(TRAD.lastIndexOf("\n$f")+1,TRAD.length()));
                                        }else{
                                            TRAD = TRAD.replace(TRAD.substring(TRAD.lastIndexOf("\n$t")+1,TRAD.length()),
                                                          T+" "+TRAD.substring(TRAD.lastIndexOf("\n$t")+1,TRAD.length()));
                                        }                                    
                                        
                                        TabTrad.put("ARRAY_ACCESS_ASS",TRAD);
                                        arracc.genere = "ARRAY_ACCESS"; 

                                      } 
                                      
                                      RESULT = new Obj(arracc.testo,arracc.tipo,arracc.genere); 
                                     :}
	;
expression_opt ::=
	{: RESULT = new Obj(""); :}
        |	expression:espr {: RESULT = espr; :}
	;
expression ::=	assignment_expression:assex {: RESULT = assex; :}
	;























